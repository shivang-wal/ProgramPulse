import jsPDF from 'jspdf';
import 'jspdf-autotable';
import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';

// Generate PDF for a single project
export const generateProjectPDF = (project) => {
  try {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.width;
    const pageHeight = doc.internal.pageSize.height;
    
    // Header
    doc.setFillColor(74, 65, 115); // Purple header
    doc.rect(0, 0, pageWidth, 40, 'F');
    
    // LucyRx branding
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(20);
    doc.setFont(undefined, 'bold');
    doc.text('Program Pulse', 20, 25);
    doc.setFontSize(10);
    doc.setFont(undefined, 'normal');
    doc.text('keeping a pulse on all LucyRx initiatives', 20, 35);
    
    // Date
    const currentDate = new Date().toLocaleDateString();
    doc.text(`Generated: ${currentDate}`, pageWidth - 80, 25);
    
    // Project Title
    doc.setTextColor(74, 65, 115);
    doc.setFontSize(18);
    doc.setFont(undefined, 'bold');
    doc.text(project.name || 'Project Details', 20, 60);
    
    // Status Badge
    const statusColors = {
      'On Track': [16, 185, 129],
      'At Risk': [245, 158, 11],
      'Delayed': [239, 68, 68],
      'Completed': [99, 102, 241]
    };
    
    const statusColor = statusColors[project.status] || statusColors['On Track'];
    doc.setFillColor(...statusColor);
    doc.roundedRect(20, 70, 40, 12, 2, 2, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(10);
    doc.text(project.status || 'On Track', 22, 78);
    
    // Project Details
    let yPos = 100;
    doc.setTextColor(74, 65, 115);
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    
    const sections = [
      { title: 'Completed This Week', content: project.completedThisWeek },
      { title: 'Risks', content: project.risks },
      { title: 'Escalation', content: project.escalation },
      { title: 'Planned Next Week', content: project.plannedNextWeek }
    ];
    
    sections.forEach((section) => {
      if (section.content && section.content.trim()) {
        doc.text(section.title, 20, yPos);
        doc.setFont(undefined, 'normal');
        doc.setFontSize(10);
        
        const lines = doc.splitTextToSize(section.content, pageWidth - 40);
        doc.text(lines, 20, yPos + 8);
        yPos += 8 + (lines.length * 5) + 10;
        
        doc.setFont(undefined, 'bold');
        doc.setFontSize(12);
      }
    });
    
    // Bug Severity Table - Use manual table creation instead of autoTable
    if (project.bugs) {
      const bugs = project.bugs;
      const totalBugs = bugs.critical + bugs.high + bugs.medium + bugs.low;
      
      doc.text('Bug Severity Matrix', 20, yPos);
      yPos += 20;
      
      // Manual table creation
      const startX = 20;
      const rowHeight = 12;
      const colWidths = [35, 25, 25, 25, 25, 25];
      
      // Table header
      doc.setFillColor(245, 240, 255);
      doc.rect(startX, yPos, colWidths.reduce((a, b) => a + b, 0), rowHeight, 'F');
      
      doc.setTextColor(74, 65, 115);
      doc.setFontSize(9);
      doc.setFont(undefined, 'bold');
      
      let currentX = startX + 2;
      const headers = ['Severity/Priority', '1-Critical', '2-High', '3-Medium', '4-Low', 'Total'];
      headers.forEach((header, i) => {
        doc.text(header, currentX, yPos + 8);
        currentX += colWidths[i];
      });
      
      yPos += rowHeight;
      
      // Table rows
      const rows = [
        ['Critical', bugs.critical.toString(), '0', '0', '0', bugs.critical.toString()],
        ['High', '0', bugs.high.toString(), '0', '0', bugs.high.toString()],
        ['Medium', '0', '0', bugs.medium.toString(), '0', bugs.medium.toString()],
        ['Low', '0', '0', '0', bugs.low.toString(), bugs.low.toString()],
        ['Total', bugs.critical.toString(), bugs.high.toString(), bugs.medium.toString(), bugs.low.toString(), totalBugs.toString()]
      ];
      
      doc.setFont(undefined, 'normal');
      
      rows.forEach((row, rowIndex) => {
        // Alternate row colors
        if (rowIndex % 2 === 0) {
          doc.setFillColor(250, 250, 250);
          doc.rect(startX, yPos, colWidths.reduce((a, b) => a + b, 0), rowHeight, 'F');
        }
        
        currentX = startX + 2;
        row.forEach((cell, colIndex) => {
          if (colIndex === 0 || rowIndex === 4) { // First column or total row
            doc.setFont(undefined, 'bold');
          } else {
            doc.setFont(undefined, 'normal');
          }
          doc.text(cell, currentX, yPos + 8);
          currentX += colWidths[colIndex];
        });
        
        yPos += rowHeight;
      });
    }
    
    // Footer
    yPos += 20;
    doc.setDrawColor(220, 220, 220);
    doc.line(20, yPos, pageWidth - 20, yPos);
    doc.setTextColor(150, 150, 150);
    doc.setFontSize(8);
    doc.text('Generated by Program Pulse - LucyRx Project Management System', 20, yPos + 10);
    
    return doc;
  } catch (error) {
    console.error('Error generating PDF:', error);
    throw new Error('Failed to generate PDF: ' + error.message);
  }
};

// Generate PDF for all projects
export const generateAllProjectsPDF = (projects) => {
  try {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.width;
    
    // Header
    doc.setFillColor(74, 65, 115);
    doc.rect(0, 0, pageWidth, 40, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(20);
    doc.setFont(undefined, 'bold');
    doc.text('Program Pulse', 20, 25);
    doc.setFontSize(10);
    doc.setFont(undefined, 'normal');
    doc.text('Project Dashboard Summary', 20, 35);
    
    const currentDate = new Date().toLocaleDateString();
    doc.text(`Generated: ${currentDate}`, pageWidth - 80, 25);
    
    // Summary Table
    doc.setTextColor(74, 65, 115);
    doc.setFontSize(16);
    doc.setFont(undefined, 'bold');
    doc.text('Projects Overview', 20, 60);
    
    // Manual table for all projects
    let yPos = 80;
    const startX = 20;
    const rowHeight = 15;
    const colWidths = [50, 30, 25, 20, 20, 20, 20];
    
    // Table header
    doc.setFillColor(74, 65, 115);
    doc.rect(startX, yPos, colWidths.reduce((a, b) => a + b, 0), rowHeight, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(10);
    doc.setFont(undefined, 'bold');
    
    let currentX = startX + 2;
    const headers = ['Project Name', 'Status', 'Total Bugs', 'Critical', 'High', 'Medium', 'Low'];
    headers.forEach((header, i) => {
      doc.text(header, currentX, yPos + 10);
      currentX += colWidths[i];
    });
    
    yPos += rowHeight;
    
    // Project rows
    doc.setTextColor(74, 65, 115);
    doc.setFontSize(9);
    
    projects.forEach((project, index) => {
      const bugs = project.bugs || { critical: 0, high: 0, medium: 0, low: 0 };
      const totalBugs = bugs.critical + bugs.high + bugs.medium + bugs.low;
      
      // Alternate row colors
      if (index % 2 === 0) {
        doc.setFillColor(248, 248, 248);
        doc.rect(startX, yPos, colWidths.reduce((a, b) => a + b, 0), rowHeight, 'F');
      }
      
      const row = [
        project.name || 'Unnamed Project',
        project.status || 'Unknown',
        totalBugs.toString(),
        bugs.critical.toString(),
        bugs.high.toString(),
        bugs.medium.toString(),
        bugs.low.toString()
      ];
      
      currentX = startX + 2;
      row.forEach((cell, colIndex) => {
        // Truncate long project names
        const maxLength = colIndex === 0 ? 15 : cell.length;
        const displayText = cell.length > maxLength ? cell.substring(0, maxLength) + '...' : cell;
        doc.text(displayText, currentX, yPos + 10);
        currentX += colWidths[colIndex];
      });
      
      yPos += rowHeight;
      
      // Add new page if needed
      if (yPos > 250) {
        doc.addPage();
        yPos = 20;
      }
    });
    
    return doc;
  } catch (error) {
    console.error('Error generating all projects PDF:', error);
    throw new Error('Failed to generate PDF: ' + error.message);
  }
};

// Export single project as PDF
export const exportProjectAsPDF = (project) => {
  try {
    console.log('Exporting project:', project);
    const doc = generateProjectPDF(project);
    const fileName = `${project.name?.replace(/[^a-z0-9]/gi, '_') || 'project'}_${new Date().toISOString().split('T')[0]}.pdf`;
    doc.save(fileName);
    console.log('PDF export successful:', fileName);
  } catch (error) {
    console.error('Failed to export project as PDF:', error);
    alert('Failed to generate PDF: ' + error.message);
  }
};

// Export all projects as PDF
export const exportAllProjectsAsPDF = (projects) => {
  try {
    console.log('Exporting all projects:', projects.length);
    if (!projects || projects.length === 0) {
      alert('No projects to export');
      return;
    }
    const doc = generateAllProjectsPDF(projects);
    const fileName = `all_projects_${new Date().toISOString().split('T')[0]}.pdf`;
    doc.save(fileName);
    console.log('PDF export successful:', fileName);
  } catch (error) {
    console.error('Failed to export all projects as PDF:', error);
    alert('Failed to generate PDF: ' + error.message);
  }
};

// Export projects as Excel
export const exportProjectsAsExcel = (projects) => {
  try {
    console.log('Exporting projects as Excel:', projects.length);
    if (!projects || projects.length === 0) {
      alert('No projects to export');
      return;
    }
    
    // Create workbook
    const wb = XLSX.utils.book_new();
    
    // Projects Summary Sheet
    const summaryData = projects.map(project => {
      const bugs = project.bugs || { critical: 0, high: 0, medium: 0, low: 0 };
      const totalBugs = bugs.critical + bugs.high + bugs.medium + bugs.low;
      
      return {
        'Project Name': project.name || 'Unnamed Project',
        'Status': project.status || 'Unknown',
        'Completed This Week': project.completedThisWeek || '',
        'Risks': project.risks || '',
        'Escalation': project.escalation || '',
        'Planned Next Week': project.plannedNextWeek || '',
        'Total Bugs': totalBugs,
        'Critical Bugs': bugs.critical,
        'High Bugs': bugs.high,
        'Medium Bugs': bugs.medium,
        'Low Bugs': bugs.low,
        'Created Date': project.createdAt ? new Date(project.createdAt).toLocaleDateString() : ''
      };
    });
    
    const summaryWs = XLSX.utils.json_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(wb, summaryWs, 'Projects Summary');
  
  // Bug Details Sheet
  const bugDetails = [];
  projects.forEach(project => {
    const bugs = project.bugs || { critical: 0, high: 0, medium: 0, low: 0 };
    
    ['critical', 'high', 'medium', 'low'].forEach(severity => {
      if (bugs[severity] > 0) {
        bugDetails.push({
          'Project Name': project.name || 'Unnamed Project',
          'Project Status': project.status || 'Unknown',
          'Bug Severity': severity.charAt(0).toUpperCase() + severity.slice(1),
          'Bug Count': bugs[severity],
          'Date': new Date().toLocaleDateString()
        });
      }
    });
  });
  
  if (bugDetails.length > 0) {
    const bugWs = XLSX.utils.json_to_sheet(bugDetails);
    XLSX.utils.book_append_sheet(wb, bugWs, 'Bug Details');
  }
  
  // Status Summary Sheet
  const statusSummary = {};
  projects.forEach(project => {
    const status = project.status || 'Unknown';
    if (statusSummary[status]) {
      statusSummary[status]++;
    } else {
      statusSummary[status] = 1;
    }
  });
  
  const statusData = Object.entries(statusSummary).map(([status, count]) => ({
    'Status': status,
    'Project Count': count,
    'Percentage': ((count / projects.length) * 100).toFixed(1) + '%'
  }));
  
  const statusWs = XLSX.utils.json_to_sheet(statusData);
  XLSX.utils.book_append_sheet(wb, statusWs, 'Status Summary');
  
    // Save file
    const fileName = `program_pulse_export_${new Date().toISOString().split('T')[0]}.xlsx`;
    XLSX.writeFile(wb, fileName);
    console.log('Excel export successful:', fileName);
  } catch (error) {
    console.error('Failed to export as Excel:', error);
    alert('Failed to generate Excel file: ' + error.message);
  }
};